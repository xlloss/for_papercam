//==============================================================================
//
//  File        : sensor_ps5250.c
//  Description : Firmware Sensor Control File
//  Author      :
//  Revision    : 1.0
//
//==============================================================================

//==============================================================================
//
//                              INCLUDE FILE
//
//==============================================================================

#include "includes_fw.h"
#include "Customer_config.h"
#include "mmpf_pll.h"


#if (SENSOR_EN)
#if (BIND_SENSOR_PS5250)

#include "mmpf_sensor.h"
#include "sensor_Mod_Remapping.h"
#include "isp_if.h"
/*
james.yang@primesensor.com
[0711]
Bank  address orignal new
Bank0      9E       A   8
Bank0      DC      1B  31
Bank1      7C       E  38
Bank1      D1      44   4
Bank1      D3      14  17
Bank1      E2      4D  1D
Bank1      F8       0  40
Bank5      43       4   5
*/

//#define LOW_POWER_MODE    (1) // lower 35mW

//==============================================================================
//
//                              GLOBAL VARIABLE
//
//==============================================================================

// Resolution Table
MMPF_SENSOR_RESOLUTION m_SensorRes = 
{
	2,   // ubSensorModeNum
	0,    // ubDefPreviewMode
	0,    // ubDefCaptureMode
	3000, // usPixelSize
// 	Mode0   Mode1   Mode2	Mode3	Mode4   Mode5   Mode6   Mode7   Mode8   Mode9   Mode10  Mode11	Mode12	Mode13
    {1,		1		},    	// usVifGrabStX
    {1, 	1		},    	// usVifGrabStY 
    {1928,	1928	}, 	// usVifGrabW -> WOI_HSIZE(0xA9,0xAA)
    {1088,	1088    }, 	// usVifGrabH -> WOI_VSIZE(0xA5,0xA6)
/* #if (CHIP == MCR_V2) */
    {1,		1       },    	// usBayerInGrabX
    {1,		1       },    	// usBayerInGrabY
    {8,		8       },   	// usBayerInDummyX
    {8,		8       },    	// usBayerInDummyY
    {1920,	1280    },	// usBayerOutW
    {1080,	 720    }, 	// usBayerOutH
/* #endif */
    {1920,	1280    }, 	// usScalInputW
    {1080,	720    }, 	// usScalInputH
    {300,	300     }, 	// usTargetFpsx10
    {1124,	1124	},	// usVsyncLine -> LPF(0x0A,0x0B)
    {1,		1		},    	// ubWBinningN
    {1,		1		},    	// ubWBinningM
    {1,		1		},    	// ubHBinningN
    {1,		1		},     // ubHBinningM
    {0x00,	0x00	},  // ubCustIQmode
    {0x00,	0x00    }   // ubCustAEmode
};

// OPR Table and Vif Setting
MMPF_SENSOR_OPR_TABLE 	m_OprTable;
MMPF_SENSOR_VIF_SETTING m_VifSetting;

// IQ Table
const ISP_UINT8 Sensor_IQ_CompressedText[] = 
{
#ifdef PROJECT_LD
#include "isp_8428_iq_data_v3_PS5250_ezmode_20170830.xls.ciq.txt"
#else
#include "isp_8428_iq_data_v3_PS5250_ezmode_20170803.xls.ciq.txt"
#endif
};

#if (SUPPORT_UVC_ISP_EZMODE_FUNC==1) //TBD
const  ISP_UINT8 Sensor_EZ_IQ_CompressedText[] =
{
//#include "eziq_0509.txt"
0
};

ISP_UINT32 eziqsize = sizeof(Sensor_EZ_IQ_CompressedText);
#endif

// I2cm Attribute
static MMP_I2CM_ATTR m_I2cmAttr = 
{
	MMP_I2CM0,      // i2cmID
    0x48,       	// ubSlaveAddr
	8, 			    // ubRegLen
	8, 				// ubDataLena4
	0, 				// ubDelayTime
	MMP_FALSE, 		// bDelayWaitEn
	MMP_TRUE, 		// bInputFilterEn
	MMP_FALSE, 		// b10BitModeEn
	MMP_FALSE, 		// bClkStretchEn
	0, 				// ubSlaveAddr1
	0, 				// ubDelayCycle
	0, 				// ubPadNum
	400000, 		// ulI2cmSpeed 150KHZ
	MMP_TRUE, 		// bOsProtectEn
	0, 			// sw_clk_pin
	0, 			// sw_data_pin
	MMP_FALSE, 		// bRfclModeEn
	MMP_FALSE,      // bWfclModeEn
	MMP_FALSE,		// bRepeatModeEn
    0               // ubVifPioMdlId
};

// 3A Timing
MMPF_SENSOR_AWBTIMIMG m_AwbTimeSlow = 
{
	6, 	// ubPeriod
	1, 	// ubDoAWBFrmCnt
	3 	// ubDoCaliFrmCnt
};

MMPF_SENSOR_AETIMIMG m_AeTimeSlow = 
{
	4, 	// ubPeriod
	0, 	// ubFrmStSetShutFrmCnt
	0 	// ubFrmStSetGainFrmCnt
};

MMPF_SENSOR_AFTIMIMG m_AfTimeSlow = 
{
	1, 	// ubPeriod
	0 	// ubDoAFFrmCnt
};

MMPF_SENSOR_AWBTIMIMG m_AwbTime = 
{
	2, 	// ubPeriod
	0, 	// ubDoAWBFrmCnt
	2 	// ubDoCaliFrmCnt
};

MMPF_SENSOR_AETIMIMG m_AeTime = 
{
	3, 	// ubPeriod
	0, 	// ubFrmStSetShutFrmCnt
	0 	// ubFrmStSetGainFrmCnt
};

MMPF_SENSOR_AFTIMIMG m_AfTime = 
{
	1, 	// ubPeriod
	0 	// ubDoAFFrmCnt
};




const ISP_UINT16 PS5250_GainTable[] = {
	4096, //1x
	3855, 
	3641, 
	3449, 
	3277,
  3121, 
  2979, 
  2849,
  2731, 
  2621,
  2521, 
  2427, 
  2341, 
  2260, 
  2185, 
  2114, 
  2048, //2x
  1928, 
  1820, 
  1725, 
  1638, 
  1560,
  1489, 
  1425, 
  1365, 
  1311, 
  1260, 
  1214, 
  1170, 
  1130, 
  1092, 
  1057, 
  1024, //4x
  964,  
  910, 
  862, 
  819,  
  780,  
  745,  
  712, 
  683,  
  655,  
  630,  
  607,  
  585, 
  565,  
  546,  
  529,  
  512, //8x
  482, 
  455,  
  431,  
  410,  
  390,  
  372,  
  356,  
  341,  
  328,  
  315,  
  303,
  293,  
  282,  
  273,  
  264,  
  256, //16x
  241,  
  227,  
  215,  
  205,  
  195, 
  186,  
  178,  
  171,  
  164,  
  158, 
  152,  
  146,  
  141,  
  137,  
  132, 
  128  //32x   
};

#define SZ_GAIN_TBL (sizeof(PS5250_GainTable) /sizeof(ISP_UINT16) )

//==============================================================================
//
//                              FUNCTIONS
//
//==============================================================================

#if 0
void ____Sensor_Init_OPR_Table____(){ruturn;} //dummy
#endif

ISP_UINT16 SNR_PS5250_Reg_Unsupport[] =
{
    SENSOR_DELAY_REG, 100 // delay
};

ISP_UINT16 SNR_PS5250_Reg_Init_Customer[] =
{
	// TBD
	SENSOR_DELAY_REG, 1,//100 // delay
};

#if 0
void ____Sensor_Res_OPR_Table____(){ruturn;} //dummy
#endif

#define __FAST_INIT__   (1)
ISP_UINT16 SNR_PS5250_Reg_1920x1080_30P[] =
{
#if (SENSOR_IF == SENSOR_IF_MIPI_2_LANE) && (__FAST_INIT__== 1)
0xEF ,0x01,
0x05 ,0x03,
0xEF ,0x00, //bank0
//0x11 ,0x00,
0x54 ,0xC3,
0x55 ,0x21,
0x56 ,0x1D,
0x57 ,0x2D,
0x58 ,0x3D,
0x5F ,0x90,
0x60 ,0x9A,
0x61 ,0xFF,
0x63 ,0x46,
0x69 ,0x05,
0x6A ,0x36,
0x73 ,0x96,
0x74 ,0x96,
0x75 ,0x00,
0x76 ,0xFD,
0x77 ,0xFD,
0x78 ,0x77,
0x7A ,0x00,
0x7B ,0x03,
0x7C ,0x96,
0x7D ,0xF8,
0x7F ,0xA0,
0x80 ,0x0E,
0x81 ,0x80,//default=62 20170911 JAMES
0x82 ,0x71,
0x83 ,0x01,
0x85 ,0x96,
0x87 ,0xC8,
0x9E ,0x08,
0xA2 ,0x30,
0xA3 ,0x03,
0xD9 ,0x64,
0xDA ,0x12,
0xDB ,0x84,
0xDC ,0x31,
0xED ,0x01,
0xEF ,0x01, //bank1
0x04 ,0x10,
0x05 ,0x03,
0x09 ,0x00,
0x0A ,0x04,
0x0B ,0x64,
0x0D ,0x02,
0x1E ,0x46, //default=43 20170608 JAMES
0x20 ,0x02,
0x27 ,0x08,
0x28 ,0xCC,
0x29 ,0x02, //default=00 20170608 JAMES
0x2A ,0x08,
0x2B ,0x93, //default=C8 20170608 JAMES
0x2C ,0x10,
0x2D ,0x12,
0x2E ,0x78, //default=5A 20170911 JAMES
0x37 ,0x90,
0x38 ,0x44,
0x39 ,0xC2,
0x3A ,0xFF,
0x3B ,0x0A,
0x3E ,0x20,
0x3F ,0x22,
0x40 ,0xFF,
0x41 ,0x0F, //default=1F 20170608 JAMES
0x42 ,0xC8, //default=68 20170608 JAMES
0x4A ,0x21, //default=22 20170608 JAMES
0x4B ,0x1E,
0x4C ,0xBE, //default=5F 20170608 JAMES
0x4F ,0x01,
0x51 ,0x03,
0x52 ,0xE8, //default=B8 20170608 JAMES
0x56 ,0x0A, //default=64 20170608 JAMES
0x60 ,0x78, //default=5A 20170911 JAMES
0x6F ,0x06,
0x7C ,0x38, //default=0E 20170711 JAMES
0x8B ,0x46,
0x99 ,0x02,
0xA6 ,0x40,
0xA8 ,0x00,
0xAA ,0x88,
0xB0 ,0x50,
0xB4 ,0x50,
0xC6 ,0x00,
0xC7 ,0x00,
0xCA ,0x00,
0xCB ,0x00,
0xD0 ,0xC2,
0xD1 ,0x04, //default=44 20170711 JAMES
0xD3 ,0x17, //default=14 20170711 JAMES
0xD8 ,0x5E, //default=4E 20170608 JAMES
0xD9 ,0x66, //default=NC 20170608 JAMES
0xDD ,0x72, //default=62 20170911 JAMES
0xDE ,0x43,
0xE2 ,0x6D, //default=1D 20170911 JAMES
0xE3 ,0x21,
0xEA ,0x7A,
0xF5 ,0x01,
0xF6 ,0xC8,
0xF7 ,0x02,
0xF0 ,0x03,
0xF4 ,0x06,
0xF2 ,0x11,
0xF1 ,0x0A,
0xF5 ,0x11,
0xF8 ,0x00,//default=40 20170911 JAMES
0xF9 ,0x15,
0x09 ,0x01,
0xEF ,0x02,//bank2
0x20 ,0x01,
0x21 ,0x18,
0x22 ,0x0C,
0x23 ,0x08,
0x24 ,0x05,
0x25 ,0x03,
0x26 ,0x02,
0x27 ,0x02,
0x28 ,0x07,
0x29 ,0x08,
0x33 ,0x85,
#ifdef PROJECT_LD
0x47 ,0x10,
0x49 ,0x10,
0x4B ,0x10,
0x4D ,0x10,
#else
0x47 ,0x04,
0x49 ,0x04,
0x4B ,0x04,
0x4D ,0x04,
#endif
0xCB ,0xBD,
0xE3 ,0x1B,
0xFD ,0x18,
0xFE ,0x9E,
0xED ,0x01,
0xEF ,0x05, //bank5
0x03 ,0x10,
0x04 ,0xE0,
0x05 ,0x01,
0x06 ,0x04,
0x07 ,0x80,
0x08 ,0x02,
0x09 ,0x09,
0x0A ,0x05,
0x0B ,0x06,
0x0C ,0x04,
0x0D ,0xA1,
0x0E ,0x00,
0x0F ,0x00,
0x10 ,0x02,
0x11 ,0x01,
0x12 ,0x00,
0x13 ,0x00,
0x14 ,0xB8,
0x15 ,0x07,
0x16 ,0x06,
0x17 ,0x03,
0x18 ,0x01,
0x19 ,0x04,
0x1A ,0x06,
0x1B ,0x03,
0x1C ,0x04,
0x1D ,0x08,
0x1E ,0x1A,
0x1F ,0x00,
0x20 ,0x00,
0x21 ,0x1E,
0x22 ,0x1E,
0x23 ,0x01,
0x24 ,0x04,
0x27 ,0x00,
0x28 ,0x00,
0x2A ,0x08,
0x2B ,0x02,
0x2C ,0xA4,
0x2D ,0x06,
0x2E ,0x00,
0x2F ,0x05,
0x30 ,0xE0,
0x31 ,0x01,
0x32 ,0x00,
0x33 ,0x00,
0x34 ,0x00,
0x35 ,0x00,
0x36 ,0x00,
0x37 ,0x00,
0x38 ,0x0E,
0x39 ,0x01,
0x3A ,0x02,
0x3B ,0x00,
0x3C ,0x00,
0x3D ,0x00,
0x3E ,0x00,
0x3F ,0x00,
0x42 ,0x00,
0x40 ,0x16, //24M=16 27M=19
0x41 ,0x12,
0x47 ,0x05,
0x48 ,0x00,
0x49 ,0x01,
0x4D ,0x02,
0x4F ,0x00,
0x54 ,0x0A,
0x55 ,0x01,
0x56 ,0x0A,
0x57 ,0x01,
0x58 ,0x01,
0x59 ,0x01,
0x42 ,0x01,//MIPI PLL , PARALLEL set 0
0x43 ,0x06,//T_MIPI_sel[0], Bank5_67[1]=1
0x5B ,0x00,
0x5C ,0x00,
0x5D ,0x00,
0x5E ,0x07,
0x5F ,0x08,
0x60 ,0x00,
0x61 ,0x00,
0x62 ,0x00,
0x63 ,0x28,
0x64 ,0x30,
0x65 ,0x9E,
0x66 ,0xB9,
0x67 ,0x52,
0x68 ,0x70,
0x69 ,0x4E,
0x70 ,0x00,
0x71 ,0x00,
0x72 ,0x00,
0x90 ,0x04,
0x91 ,0x01,
0x92 ,0x00,
0x93 ,0x00,
0x94 ,0x04,
0x96 ,0x00,
0x97 ,0x01,
0x98 ,0x01,
0xA0 ,0x00,
0xA1 ,0x01,
0xA2 ,0x00,
0xA3 ,0x01,
0xA4 ,0x00,
0xA5 ,0x01,
0xA6 ,0x00,
0xA7 ,0x00,
0xAA ,0x00,
0xAB ,0x0F,
0xAC ,0x08,
0xAD ,0x09,
0xAE ,0x0A,
0xAF ,0x0B,
0xB0 ,0x00,
0xB1 ,0x00,
0xB2 ,0x01,
0xB3 ,0x00,
0xB4 ,0x00,
0xB5 ,0x0A,
0xB6 ,0x0A,
0xB7 ,0x0A,
0xB8 ,0x0A,
0xB9 ,0x00,
0xBA ,0x00,
0xBB ,0x00,
0xBC ,0x00,
0xBD ,0x00,
0xBE ,0x00,
0xBF ,0x00,
0xC0 ,0x00,
0xC1 ,0x00,
0xC2 ,0x00,
0xC3 ,0x00,
0xC4 ,0x00,
0xC5 ,0x00,
0xC6 ,0x00,
0xC7 ,0x00,
0xC8 ,0x00,
0xD3 ,0x80,
0xD4 ,0x00,
0xD5 ,0x00,
0xD6 ,0x03,
0xD7 ,0x77,
0xD8 ,0x00,
0xED ,0x01,
0xEF ,0x00,
0x11 ,0x00, //數位Cmd_GatedAllClk放開
0xEF ,0x01,
0x02 ,0xFB, //RstN TG
0x05 ,0x3B,//Vsync delay=3
0x09 ,0x01,
0xEF ,0x05,
0x0F ,0x01,
0xED ,0x01,
#endif
  
#if (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)  && (__FAST_INIT__== 0)
0xEF ,0x01,
0x05 ,0x03,
0xEF ,0x00, //bank0
0x06 ,0x02,
0x0B ,0x00,
0x0C ,0xA0,
0x10 ,0x80, //Cmd_BYTECLK_InvSel=1
//11 ,0x00, //數位Cmd_GatedAllClk先不放(預設值keep 1)
0x12 ,0x80,
0x13 ,0x00,
0x14 ,0xBF,
0x15 ,0x07,
0x16 ,0xBF,
0x17 ,0xBF,
0x18 ,0xBF,
0x19 ,0x64,
0x1B ,0x64,
0x1C ,0x64,
0x1D ,0x64,
0x1E ,0x64,
0x1F ,0x64,
0x20 ,0x64,
0x21 ,0x00,
0x23 ,0x00,
0x24 ,0x00,
0x25 ,0x00,
0x26 ,0x00,
0x27 ,0x00,
0x28 ,0x00,
0x29 ,0x64,
0x2B ,0x64,
0x2C ,0x64,
0x2D ,0x64,
0x2E ,0x64,
0x2F ,0x64,
0x30 ,0x64,
0x31 ,0x0F,
0x32 ,0x00,
0x33 ,0x64,
0x34 ,0x64,
0x54 ,0xC3,
0x55 ,0x21,
0x56 ,0x1D,
0x57 ,0x2D,
0x58 ,0x3D,
0x5A ,0x00,
0x5B ,0x00,
0x5C ,0x00,
0x5E ,0x01,
0x5F ,0x90,
0x60 ,0x9A,
0x61 ,0xFF,
0x62 ,0x07,
0x63 ,0x46,
0x64 ,0x05,
0x65 ,0x82,
0x66 ,0x05,
0x67 ,0xBE,
0x68 ,0x05,
0x69 ,0x05,
0x6A ,0x36,
0x6B ,0x00,
0x6C ,0x00,
0x6D ,0x00,
0x6E ,0x00,
0x6F ,0x20,
0x70 ,0x00,
0x71 ,0x1C,
0x72 ,0x00,
0x73 ,0x96,
0x74 ,0x96,
0x75 ,0x00,
0x76 ,0xFD, //default=2F 20170608 JAMES
0x77 ,0xFD, //default=2F 20170608 JAMES
0x78 ,0x77, //default=88 20170608 JAMES
0x79 ,0x34,
0x7A ,0x00,
0x7B ,0x03,
0x7C ,0x96,
0x7D ,0xF8, //default=2A 20170608 JAMES
0x7E ,0x00,
0x7F ,0xA0,
0x80 ,0x0E,
0x81 ,0x80,//default=62 20170911 JAMES
0x82 ,0x71, //default=81 20170608 JAMES
0x83 ,0x01,
0x84 ,0x00,
0x85 ,0x96,
0x86 ,0x00,
0x87 ,0xC8,
0x88 ,0x09,
0x89 ,0x01,
0x8B ,0x00,
0x8C ,0x00,
0x8D ,0x00,
0x8E ,0x00,
0x8F ,0x00,
0x90 ,0x00,
0x91 ,0x00,
0x92 ,0x11,
0x93 ,0x00,
0x94 ,0x00,
0x95 ,0x00,
0x96 ,0x00,
0x97 ,0x00,
0x99 ,0x00,
0x9A ,0x00,
0x9B ,0x09,
0x9C ,0x00,
0x9D ,0x00,
0x9E ,0x08, //default=0A 20170711 JAMES
0x9F ,0x03,
0xA0 ,0xE0,
0xA1 ,0x40,
0xA2 ,0x30, //default=10 20170608 JAMES
0xA3 ,0x03, //default=01 20170608 JAMES
0xA4 ,0xFF,
0xA6 ,0x00,
0xA8 ,0x00,
0xA9 ,0x11,
0xAA ,0x65,
0xAB ,0x65,
0xAD ,0x00,
0xAE ,0x00,
0xAF ,0x00,
0xB0 ,0x00,
0xB1 ,0x00,
0xBE ,0x05,
0xBF ,0x00,
0xC0 ,0x10,
0xC1 ,0x01,
0xC7 ,0x10,
0xC8 ,0x01,
0xC9 ,0x00,
0xCA ,0x55,
0xCB ,0x06,
0xCC ,0x09,
0xCD ,0x00,
0xCE ,0xA2,
0xCF ,0x00,
0xD0 ,0x02,
0xD1 ,0x10,
0xD2 ,0x1E,
0xD3 ,0x19,
0xD4 ,0x04,
0xD5 ,0x18,
0xD6 ,0xC8,
0xD9 ,0x64, //default=71 20170608 JAMES
0xDA ,0x12, //default=0E 20170608 JAMES
0xDB ,0x84, //default=00 20170608 JAMES
0xDC ,0x31, //default=0A 20170711 JAMES
0xF0 ,0x00,
0xF1 ,0x00,
0xF2 ,0x00,
0xF3 ,0x00,
0xF4 ,0x00,
0xF5 ,0x40,
0xF6 ,0x00,
0xF7 ,0x00,
0xF8 ,0x00,
0xED ,0x01,
0xEF ,0x01, //bank1
0x02 ,0xFF,
0x03 ,0x03,
0x04 ,0x10,
0x05 ,0x03,
0x06 ,0xFF,
0x07 ,0x04,
0x08 ,0x00,
0x09 ,0x00,
0x0A ,0x04,
0x0B ,0x64,
0x0C ,0x00,
0x0D ,0x02,
0x0E ,0x01,
0x0F ,0x2C,
0x10 ,0x00,
0x11 ,0x00,
0x12 ,0x00,
0x13 ,0x00,
0x14 ,0x01,
0x15 ,0x00,
0x16 ,0x00,
0x17 ,0x00,
0x1A ,0x00,
0x1B ,0x07,
0x1C ,0x90,
0x1D ,0x04,
0x1E ,0x46, //default=43 20170608 JAMES
0x1F ,0x00,
0x20 ,0x02,
0x21 ,0x00,
0x22 ,0xD4,
0x23 ,0x10,
0x24 ,0xA0,
0x25 ,0x00,
0x26 ,0x08,
0x27 ,0x08,
0x28 ,0xCC,
0x29 ,0x02, //default=00 20170608 JAMES
0x2A ,0x08,
0x2B ,0x93, //default=C8 20170608 JAMES
0x2C ,0x10,
0x2D ,0x12,
0x2E ,0x78, //default=5A 20170911 JAMES
0x2F ,0x10,
0x30 ,0x2E,
0x31 ,0x84,
0x32 ,0x10,
0x33 ,0x2E,
0x34 ,0x84,
0x35 ,0x01,
0x36 ,0x00,
0x37 ,0x90,
0x38 ,0x44,
0x39 ,0xC2,
0x3A ,0xFF,
0x3B ,0x0A,
0x3C ,0x08,
0x3D ,0x04,
0x3E ,0x20,
0x3F ,0x22,
0x40 ,0xFF,
0x41 ,0x0F, //default=1F 20170608 JAMES
0x42 ,0xC8, //default=68 20170608 JAMES
0x43 ,0xFF,
0x44 ,0x04,
0x47 ,0x00,
0x48 ,0x73,
0x49 ,0x0A,
0x4A ,0x21, //default=22 20170608 JAMES
0x4B ,0x1E,
0x4C ,0xBE, //default=5F 20170608 JAMES
0x4D ,0x08,
0x4E ,0x41,
0x4F ,0x01,
0x50 ,0x08,
0x51 ,0x03,
0x52 ,0xE8, //default=B8 20170608 JAMES
0x53 ,0x08,
0x54 ,0x00,
0x55 ,0x00,
0x56 ,0x0A, //default=64 20170608 JAMES
0x57 ,0x01,
0x58 ,0x2C,
0x59 ,0x00,
0x5A ,0xD6,
0x5B ,0x00,
0x5C ,0xC8,
0x5D ,0x01,
0x5E ,0x9E,
0x5F ,0x00,
0x60 ,0x78, //default=5A 20170911 JAMES
0x61 ,0x09,
0x62 ,0x4A,
0x63 ,0x18,
0x64 ,0x02,
0x65 ,0x01,
0x66 ,0x27,
0x69 ,0x07,
0x6A ,0x02,
0x6B ,0x9E,
0x6C ,0x10,
0x6D ,0xC8,
0x6E ,0x04,
0x6F ,0x06,
0x70 ,0x00,
0x71 ,0xC8,
0x72 ,0x09,
0x73 ,0x56,
0x74 ,0x00,
0x75 ,0x00,
0x76 ,0x00,
0x77 ,0x00,
0x78 ,0x00,
0x79 ,0x0F,
0x7A ,0x00,
0x7B ,0x00,
0x7C ,0x38, //default=0E 20170711 JAMES
0x7D ,0x00,
0x7E ,0x04,
0x7F ,0x00,
0x80 ,0x00,
0x83 ,0x00,
0x87 ,0x00,
0x88 ,0x0B,
0x89 ,0x00,
0x8A ,0x04,
0x8B ,0x46,
0x8C ,0x00,
0x8D ,0x00,
0x8E ,0x8A,
0x8F ,0x00,
0x90 ,0x21,
0x91 ,0xBD,
0x92 ,0x80,
0x93 ,0x00,
0x94 ,0xFF,
0x95 ,0x00,
0x96 ,0x00,
0x97 ,0x01,
0x98 ,0x02,
0x99 ,0x02,
0x9A ,0x50,
0x9B ,0x03,
0x9C ,0x54,
0x9D ,0x07,
0x9E ,0x30,
0x9F ,0x00,
0xA0 ,0x00,
0xA1 ,0x00,
0xA2 ,0x00,
0xA3 ,0x00,
0xA4 ,0x0D,
0xA5 ,0x04,
0xA6 ,0x40,
0xA7 ,0x00,
0xA8 ,0x00,
0xA9 ,0x07,
0xAA ,0x88,
0xAB ,0x01,
0xAD ,0x00,
0xAE ,0x00,
0xAF ,0x00,
0xB0 ,0x50,
0xB1 ,0x00,
0xB2 ,0x00,
0xB3 ,0x00,
0xB4 ,0x50,
0xB5 ,0x07,
0xB6 ,0x80,
0xB7 ,0x82,
0xB8 ,0x0A,
0xB9 ,0x9E,
0xBA ,0x48,
0xBB ,0xCC,
0xBC ,0x48,
0xBD ,0xC2,
0xBE ,0x48,
0xBF ,0xC2,
0xC0 ,0x54,
0xC1 ,0xCC,
0xC2 ,0x54,
0xC3 ,0x27,
0xC4 ,0x12,
0xC5 ,0x02,
0xC6 ,0x00,
0xC7 ,0x00,
0xC8 ,0x50,
0xC9 ,0xE5,
0xCA ,0x00,
0xCB ,0x00,
0xCC ,0x3C,
0xCE ,0xF0,
0xCF ,0x80,
0xD0 ,0xC2,
0xD1 ,0x04, //default=44 20170711 JAMES
0xD2 ,0x54,
0xD3 ,0x17, //default=14 20170711 JAMES
0xD4 ,0x00,
0xD5 ,0x01,
0xD6 ,0x00,
0xD7 ,0x06,
0xD8 ,0x5E, //default=4E 20170608 JAMES
0xD9 ,0x66, //default=NC 20170608 JAMES
0xDA ,0x70,
0xDB ,0x70,
0xDC ,0x10,
0xDD ,0x72, //default=62 20170911 JAMES
0xDE ,0x43,
0xDF ,0x40,
0xE0 ,0x42,
0xE1 ,0x11,
0xE2 ,0x6D, //default=1D 20170911 JAMES
0xE3 ,0x21,
0xE4 ,0x60,
0xE6 ,0x00,
0xE7 ,0x00,
0xEA ,0x7A,
0xF5 ,0x01,
0xF6 ,0xC8,
0xF7 ,0x02,
0xF0 ,0x03,
0xF4 ,0x06,
0xF2 ,0x11,
0xF1 ,0x0A,
0xF5 ,0x11,
//F1 ,0x0A,
//F2 ,0x11,
//F4 ,0x06,
//F5 ,0x11,
//F6 ,0xC8,
//F7 ,0x02,
0xF8 ,0x00,//default=40 20170911 JAMES
0xF9 ,0x15,
0xFA ,0x3D,
0xFB ,0x02,
0xFC ,0x28,
0xFD ,0x32,
0x09 ,0x01,
0xEF ,0x02, //bank2
0x10 ,0x00,
0x20 ,0x01,
0x21 ,0x18,
0x22 ,0x0C,
0x23 ,0x08,
0x24 ,0x05,
0x25 ,0x03,
0x26 ,0x02,
0x27 ,0x02,
0x28 ,0x07,
0x29 ,0x08,
0x2E ,0x00,
0x30 ,0xBF,
0x31 ,0x06,
0x32 ,0x07,
0x33 ,0x85, //default=80 20170608 JAMES
0x34 ,0x00,
0x35 ,0x00,
0x36 ,0x01,
0x37 ,0x00,
0x38 ,0x00,
0x39 ,0x00,
0x3A ,0xCE,
0x3B ,0x17,
0x3C ,0x64,
0x3D ,0x04,
0x3E ,0x00,
0x3F ,0x0A,
0x40 ,0x0A,
0x41 ,0x09,
0x42 ,0x0A,
0x43 ,0x09,
0x45 ,0x00,
0x46 ,0x00,
#ifdef PROJECT_LD
0x47 ,0x10,//B OB
0x48 ,0x00,
0x49 ,0x10,//Gb
0x4A ,0x00,
0x4B ,0x10,//Gr
0x4C ,0x00,
0x4D ,0x10,//R
#else
0x47 ,0x04,//B OB
0x48 ,0x00,
0x49 ,0x04,//Gb
0x4A ,0x00,
0x4B ,0x04,//Gr
0x4C ,0x00,
0x4D ,0x04,//R
#endif
0x88 ,0x01,
0xA0 ,0x00,
0xA1 ,0x00,
0xA2 ,0x00,
0xA3 ,0x00,
0xA4 ,0x00,
0xA5 ,0x00,
0xA6 ,0x00,
0xA7 ,0x00,
0xA9 ,0x00,
0xAA ,0x00,
0xAB ,0x00,
0xB2 ,0x01,
0xB3 ,0x00,
0xB4 ,0x03,
0xB5 ,0x01,
0xB6 ,0x04,
0xB7 ,0x01,
0xB8 ,0x04,
0xB9 ,0x00,
0xBA ,0x00,
0xBB ,0x00,
0xBC ,0x00,
0xBD ,0x00,
0xBE ,0x00,
0xCB ,0xBD,
0xCC ,0x00,
0xCD ,0x00,
0xCE ,0x00,
0xCF ,0x00,
0xD0 ,0x00,
0xD1 ,0x00,
0xD2 ,0x00,
0xD3 ,0x00,
0xD4 ,0x01,
0xD5 ,0x00,
0xD6 ,0x00,
0xD7 ,0x00,
0xD8 ,0x00,
0xD9 ,0x00,
0xDA ,0x00,
0xDB ,0x00,
0xDC ,0x00,
0xDD ,0xF0,
0xDE ,0x04,
0xDF ,0x97,
0xE0 ,0x50,
0xE1 ,0x50,
0xE2 ,0x14,
0xE3 ,0x1B,
0xE4 ,0x3F,
0xE5 ,0xFF,
0xE6 ,0x00,
0xF0 ,0x00,
0xF1 ,0x00,
0xF2 ,0x00,
0xF3 ,0x00,
0xF6 ,0x00,
0xF7 ,0x00,
0xFD ,0x18,
0xFE ,0x9E,
0xED ,0x01,
0xEF ,0x05, //bank5
0x03 ,0x10,
0x04 ,0xE0,
0x05 ,0x01,
0x06 ,0x04,
0x07 ,0x80,
0x08 ,0x02,
0x09 ,0x09,
0x0A ,0x05,
0x0B ,0x06,
0x0C ,0x04,
0x0D ,0xA1,
0x0E ,0x00,
0x0F ,0x00,
0x10 ,0x02,
0x11 ,0x01,
0x12 ,0x00,
0x13 ,0x00,
0x14 ,0xB8,
0x15 ,0x07,
0x16 ,0x06,
0x17 ,0x03,
0x18 ,0x01,
0x19 ,0x04,
0x1A ,0x06,
0x1B ,0x03,
0x1C ,0x04,
0x1D ,0x08,
0x1E ,0x1A,
0x1F ,0x00,
0x20 ,0x00,
0x21 ,0x1E,
0x22 ,0x1E,
0x23 ,0x01,
0x24 ,0x04,
0x27 ,0x00,
0x28 ,0x00,
0x2A ,0x08,
0x2B ,0x02,
0x2C ,0xA4,
0x2D ,0x06,
0x2E ,0x00,
0x2F ,0x05,
0x30 ,0xE0,
0x31 ,0x01,
0x32 ,0x00,
0x33 ,0x00,
0x34 ,0x00,
0x35 ,0x00,
0x36 ,0x00,
0x37 ,0x00,
0x38 ,0x0E,
0x39 ,0x01,
0x3A ,0x02,
0x3B ,0x00,
0x3C ,0x00,
0x3D ,0x00,
0x3E ,0x00,
0x3F ,0x00,
0x42 ,0x00,
0x40 ,0x16, //24M=16 27M=19
0x41 ,0x12,
0x47 ,0x05,
0x48 ,0x00,
0x49 ,0x01,
0x4D ,0x02,
0x4F ,0x00,
0x54 ,0x0A,
0x55 ,0x01,
0x56 ,0x0A,
0x57 ,0x01,
0x58 ,0x01,
0x59 ,0x01,
0x42 ,0x01,//MIPI PLL , PARALLEL set 0
0x43 ,0x06,//T_MIPI_sel[0], Bank5_67[1]=1
0x5B ,0x00,
0x5C ,0x00,
0x5D ,0x00,
0x5E ,0x07,
0x5F ,0x08,
0x60 ,0x00,
0x61 ,0x00,
0x62 ,0x00,
0x63 ,0x28,
0x64 ,0x30,
0x65 ,0x9E,
0x66 ,0xB9,
0x67 ,0x52,
0x68 ,0x70,
0x69 ,0x4E,
0x70 ,0x00,
0x71 ,0x00,
0x72 ,0x00,
0x90 ,0x04,
0x91 ,0x01,
0x92 ,0x00,
0x93 ,0x00,
0x94 ,0x04,
0x96 ,0x00,
0x97 ,0x01,
0x98 ,0x01,
0xA0 ,0x00,
0xA1 ,0x01,
0xA2 ,0x00,
0xA3 ,0x01,
0xA4 ,0x00,
0xA5 ,0x01,
0xA6 ,0x00,
0xA7 ,0x00,
0xAA ,0x00,
0xAB ,0x0F,
0xAC ,0x08,
0xAD ,0x09,
0xAE ,0x0A,
0xAF ,0x0B,
0xB0 ,0x00,
0xB1 ,0x00,
0xB2 ,0x01,
0xB3 ,0x00,
0xB4 ,0x00,
0xB5 ,0x0A,
0xB6 ,0x0A,
0xB7 ,0x0A,
0xB8 ,0x0A,
0xB9 ,0x00,
0xBA ,0x00,
0xBB ,0x00,
0xBC ,0x00,
0xBD ,0x00,
0xBE ,0x00,
0xBF ,0x00,
0xC0 ,0x00,
0xC1 ,0x00,
0xC2 ,0x00,
0xC3 ,0x00,
0xC4 ,0x00,
0xC5 ,0x00,
0xC6 ,0x00,
0xC7 ,0x00,
0xC8 ,0x00,
0xD3 ,0x80,
0xD4 ,0x00,
0xD5 ,0x00,
0xD6 ,0x03,
0xD7 ,0x77,
0xD8 ,0x00,
0xED ,0x01,
0xEF ,0x00,
0x11 ,0x00, //數位Cmd_GatedAllClk放開
0xEF ,0x01,
0x02 ,0xFB, //RstN TG
0x05 ,0x3B,//Vsync delay=3
0x09 ,0x01,
0xEF ,0x05,
0x0F ,0x01,
0xED ,0x01,
#endif
#if (SENSOR_IF == SENSOR_IF_PARALLEL)
0xEF ,0x01,
0x05 ,0x03,
0xEF ,0x00, //bank0
0x06 ,0x02,
0x0B ,0x00,
0x0C ,0xA0,
0x10 ,0x80, //Cmd_BYTECLK_InvSel=1
//11 ,0x00, //數位Cmd_GatedAllClk先不放(預設值keep 1)
0x12 ,0x80,
0x13 ,0x00,
0x14 ,0xBF,
0x15 ,0x07,
0x16 ,0xBF,
0x17 ,0xBF,
0x18 ,0xBF,
0x19 ,0x64,
0x1B ,0x64,
0x1C ,0x64,
0x1D ,0x64,
0x1E ,0x64,
0x1F ,0x64,
0x20 ,0x64,
0x21 ,0x00,
0x23 ,0x00,
0x24 ,0x00,
0x25 ,0x00,
0x26 ,0x00,
0x27 ,0x00,
0x28 ,0x00,
0x29 ,0x64,
0x2B ,0x64,
0x2C ,0x64,
0x2D ,0x64,
0x2E ,0x64,
0x2F ,0x64,
0x30 ,0x64,
0x31 ,0x0F,
0x32 ,0x00,
0x33 ,0x64,
0x34 ,0x64,
0x54 ,0xC3,
0x55 ,0x21,
0x56 ,0x1D,
0x57 ,0x2D,
0x58 ,0x3D,
0x5A ,0x00,
0x5B ,0x00,
0x5C ,0x00,
0x5E ,0x01,
0x5F ,0x90,
0x60 ,0x9A,
0x61 ,0xFF,
0x62 ,0x07,
0x63 ,0x46,
0x64 ,0x05,
0x65 ,0x82,
0x66 ,0x05,
0x67 ,0xBE,
0x68 ,0x05,
0x69 ,0x05,
0x6A ,0x36,
0x6B ,0x00,
0x6C ,0x00,
0x6D ,0x00,
0x6E ,0x00,
0x6F ,0x20,
0x70 ,0x00,
0x71 ,0x1C,
0x72 ,0x00,
0x73 ,0x96,
0x74 ,0x96,
0x75 ,0x00,
0x76 ,0xFD, //default=2F 20170608 JAMES
0x77 ,0xFD, //default=2F 20170608 JAMES
0x78 ,0x77, //default=88 20170608 JAMES
0x79 ,0x34,
0x7A ,0x00,
0x7B ,0x03,
0x7C ,0x96,
0x7D ,0xF8, //default=2A 20170608 JAMES
0x7E ,0x00,
0x7F ,0xA0,
0x80 ,0x0E,
0x81 ,0x62, //default=26 20170608 JAMES
0x82 ,0x71, //default=81 20170608 JAMES
0x83 ,0x01,
0x84 ,0x00,
0x85 ,0x96,
0x86 ,0x00,
0x87 ,0xC8,
0x88 ,0x09,
0x89 ,0x01,
0x8B ,0x00,
0x8C ,0x00,
0x8D ,0x00,
0x8E ,0x00,
0x8F ,0x00,
0x90 ,0x00,
0x91 ,0x00,
0x92 ,0x11,
0x93 ,0x00,
0x94 ,0x00,
0x95 ,0x00,
0x96 ,0x00,
0x97 ,0x00,
0x99 ,0x00,
0x9A ,0x00,
0x9B ,0x09,
0x9C ,0x00,
0x9D ,0x00,
0x9E ,0x08, //default=0A 20170711 JAMES
0x9F ,0x03,
0xA0 ,0xE0,
0xA1 ,0x40,
0xA2 ,0x30, //default=10 20170608 JAMES
0xA3 ,0x03, //default=01 20170608 JAMES
0xA4 ,0xFF,
0xA6 ,0x00,
0xA8 ,0x00,
0xA9 ,0x11,
0xAA ,0x65,
0xAB ,0x65,
0xAD ,0x00,
0xAE ,0x00,
0xAF ,0x00,
0xB0 ,0x00,
0xB1 ,0x00,
0xBE ,0x05,
0xBF ,0x00,
0xC0 ,0x10,
0xC1 ,0x01,
0xC7 ,0x10,
0xC8 ,0x01,
0xC9 ,0x00,
0xCA ,0x55,
0xCB ,0x06,
0xCC ,0x09,
0xCD ,0x00,
0xCE ,0xA2,
0xCF ,0x00,
0xD0 ,0x02,
0xD1 ,0x10,
0xD2 ,0x1E,
0xD3 ,0x19,
0xD4 ,0x04,
0xD5 ,0x18,
0xD6 ,0xC8,
0xD9 ,0x64, //default=71 20170608 JAMES
0xDA ,0x12, //default=0E 20170608 JAMES
0xDB ,0x84, //default=00 20170608 JAMES
0xDC ,0x31, //default=1B 20170608 JAMES
0xF0 ,0x00,
0xF1 ,0x00,
0xF2 ,0x00,
0xF3 ,0x00,
0xF4 ,0x00,
0xF5 ,0x40,
0xF6 ,0x00,
0xF7 ,0x00,
0xF8 ,0x00,
0xED ,0x01,
0xEF ,0x01, //bank1
0x02 ,0xFF,
0x03 ,0x03,
0x04 ,0x10,
0x05 ,0x03,
0x06 ,0xFF,
0x07 ,0x04,
0x08 ,0x00,
0x09 ,0x00,
0x0A ,0x04,
0x0B ,0x64,
0x0C ,0x00, 
0x0D ,0x02, 
0x0E ,0x01,
0x0F ,0x2C,
0x10 ,0x00,
0x11 ,0x00,
0x12 ,0x00,
0x13 ,0x00,
0x14 ,0x01,
0x15 ,0x00,
0x16 ,0x00,
0x17 ,0x00,
0x1A ,0x00,
0x1B ,0x07,
0x1C ,0x90,
0x1D ,0x04,
0x1E ,0x46, //default=43 20170608 JAMES
0x1F ,0x00,
0x20 ,0x02,
0x21 ,0x00,
0x22 ,0xD4,
0x23 ,0x10,
0x24 ,0xA0,
0x25 ,0x00,
0x26 ,0x08,
0x27 ,0x08,
0x28 ,0xCC,
0x29 ,0x02, //default=00 20170608 JAMES
0x2A ,0x08,
0x2B ,0x93, //default=C8 20170608 JAMES
0x2C ,0x10,
0x2D ,0x12,
0x2E ,0x5A, //default=1E 20170608 JAMES
0x2F ,0x10,
0x30 ,0x2E,
0x31 ,0x84,
0x32 ,0x10,
0x33 ,0x2E,
0x34 ,0x84,
0x35 ,0x01,
0x36 ,0x00,
0x37 ,0x90,
0x38 ,0x44,
0x39 ,0xC2,
0x3A ,0xFF,
0x3B ,0x0A,
0x3C ,0x08,
0x3D ,0x04,
0x3E ,0x20,
0x3F ,0x22,
0x40 ,0xFF,
0x41 ,0x0F, //default=1F 20170608 JAMES
0x42 ,0xC8, //default=68 20170608 JAMES
0x43 ,0xFF,
0x44 ,0x04,
0x47 ,0x00,
0x48 ,0x73,
0x49 ,0x0A,
0x4A ,0x21, //default=22 20170608 JAMES
0x4B ,0x1E,
0x4C ,0xBE, //default=5F 20170608 JAMES
0x4D ,0x08,
0x4E ,0x41,
0x4F ,0x01,
0x50 ,0x08,
0x51 ,0x03,
0x52 ,0xE8, //default=B8 20170608 JAMES
0x53 ,0x08,
0x54 ,0x00,
0x55 ,0x00,
0x56 ,0x0A, //default=64 20170608 JAMES
0x57 ,0x01,
0x58 ,0x2C,
0x59 ,0x00,
0x5A ,0xD6,
0x5B ,0x00,
0x5C ,0xC8,
0x5D ,0x01,
0x5E ,0x9E,
0x5F ,0x00,
0x60 ,0x5A, //default=1E 20170608 JAMES
0x61 ,0x09,
0x62 ,0x4A,
0x63 ,0x18,
0x64 ,0x02,
0x65 ,0x01,
0x66 ,0x27,
0x69 ,0x07,
0x6A ,0x02,
0x6B ,0x9E,
0x6C ,0x10,
0x6D ,0xC8,
0x6E ,0x04,
0x6F ,0x06,
0x70 ,0x00,
0x71 ,0xC8,
0x72 ,0x09,
0x73 ,0x56,
0x74 ,0x00,
0x75 ,0x00,
0x76 ,0x00,
0x77 ,0x00,
0x78 ,0x00,
0x79 ,0x0F,
0x7A ,0x00,
0x7B ,0x00,
0x7C ,0x38, //default=0E 20170608 JAMES
0x7D ,0x00,
0x7E ,0x04,
0x7F ,0x00,
0x80 ,0x00,
0x83 ,0x00,
0x87 ,0x00,
0x88 ,0x0B,
0x89 ,0x00,
0x8A ,0x04,
0x8B ,0x46,
0x8C ,0x00,
0x8D ,0x00,
0x8E ,0x8A,
0x8F ,0x00,
0x90 ,0x21,
0x91 ,0xBD,
0x92 ,0x80,
0x93 ,0x00,
0x94 ,0xFF,
0x95 ,0x00,
0x96 ,0x00,
0x97 ,0x01,
0x98 ,0x02,
0x99 ,0x02,
0x9A ,0x50,
0x9B ,0x03,
0x9C ,0x54,
0x9D ,0x07,
0x9E ,0x30,
0x9F ,0x00,
0xA0 ,0x00,
0xA1 ,0x00,
0xA2 ,0x00,
0xA3 ,0x00,
0xA4 ,0x0D,
0xA5 ,0x04,
0xA6 ,0x40,
0xA7 ,0x00,
0xA8 ,0x00,
0xA9 ,0x07,
0xAA ,0x88,
0xAB ,0x01,
0xAD ,0x00,
0xAE ,0x00,
0xAF ,0x00,
0xB0 ,0x50,
0xB1 ,0x00,
0xB2 ,0x00,
0xB3 ,0x00,
0xB4 ,0x50,
0xB5 ,0x07,
0xB6 ,0x80,
0xB7 ,0x82,
0xB8 ,0x0A,
0xB9 ,0x9E,
0xBA ,0x48,
0xBB ,0xCC,
0xBC ,0x48,
0xBD ,0xC2,
0xBE ,0x48,
0xBF ,0xC2,
0xC0 ,0x54,
0xC1 ,0xCC,
0xC2 ,0x54,
0xC3 ,0x27,
0xC4 ,0x12,
0xC5 ,0x02,
0xC6 ,0x00,
0xC7 ,0x00,
0xC8 ,0x50,
0xC9 ,0xE5,
0xCA ,0x00,
0xCB ,0x00,
0xCC ,0x3C,
0xCE ,0xF0,
0xCF ,0x80,
0xD0 ,0xC2,
0xD1 ,0x04, //default=44 20170608 JAMES
0xD2 ,0x54,
0xD3 ,0x17, //default=14 20170608 JAMES
0xD4 ,0x00,
0xD5 ,0x01,
0xD6 ,0x00,
0xD7 ,0x06,
0xD8 ,0x5E, //default=4E 20170608 JAMES
0xD9 ,0x66, //default=NC 20170608 JAMES
0xDA ,0x70,
0xDB ,0x70,
0xDC ,0x10,
0xDD ,0x62, //default=52 20170608 JAMES
0xDE ,0x43,
0xDF ,0x40,
0xE0 ,0x42,
0xE1 ,0x11,
0xE2 ,0x1D, //default=4D 20170711 JAMES
0xE3 ,0x21,
0xE4 ,0x60,
0xE6 ,0x00,
0xE7 ,0x00,
0xEA ,0x7A,
0xF5 ,0x01,
0xF6 ,0xC8,
0xF7 ,0x02,
0xF0 ,0x03,
0xF4 ,0x06,
0xF2 ,0x24, //DEFAULT=11
0xF1 ,0x16, //default=0A
0xF5 ,0x11,
//F1 ,0A
//F2 ,11
//F,0x4 ,06
//F,0x5 ,11
//F,0x6 ,C8
//F,0x7 ,02
0xF8 ,0x40, //default=00 20170608 JAMES
0xF9 ,0x15,
0xFA ,0x3D,
0xFB ,0x02,
0xFC ,0x28,
0xFD ,0x32,
0x09 ,0x01,
0xEF ,0x02, //bank2
0x10 ,0x00,
0x20 ,0x01,
0x21 ,0x18,
0x22 ,0x0C,
0x23 ,0x08,
0x24 ,0x05,
0x25 ,0x03,
0x26 ,0x02,
0x27 ,0x02,
0x28 ,0x07,
0x29 ,0x08,
0x2E ,0x00,
0x30 ,0xBF,
0x31 ,0x06,
0x32 ,0x07,
0x33 ,0x85, //default=80 20170608 JAMES
0x34 ,0x00,
0x35 ,0x00,
0x36 ,0x01,
0x37 ,0x00,
0x38 ,0x00,
0x39 ,0x00,
0x3A ,0xCE,
0x3B ,0x17,
0x3C ,0x64,
0x3D ,0x04,
0x3E ,0x00,
0x3F ,0x0A,
0x40 ,0x0A,
0x41 ,0x09,
0x42 ,0x0A,
0x43 ,0x09,
0x45 ,0x00,
0x46 ,0x00,
0x47 ,0x00,
0x48 ,0x00,
0x49 ,0x00,
0x4A ,0x00,
0x4B ,0x00,
0x4C ,0x00,
0x4D ,0x00,
0x88 ,0x01,
0xA0 ,0x00,
0xA1 ,0x00,
0xA2 ,0x00,
0xA3 ,0x00,
0xA4 ,0x00,
0xA5 ,0x00,
0xA6 ,0x00,
0xA7 ,0x00,
0xA9 ,0x00,
0xAA ,0x00,
0xAB ,0x00,
0xB2 ,0x01,
0xB3 ,0x00,
0xB4 ,0x03,
0xB5 ,0x01,
0xB6 ,0x04,
0xB7 ,0x01,
0xB8 ,0x04,
0xB9 ,0x00,
0xBA ,0x00,
0xBB ,0x00,
0xBC ,0x00,
0xBD ,0x00,
0xBE ,0x00,
0xCB ,0xBD,
0xCC ,0x00,
0xCD ,0x00,
0xCE ,0x00,
0xCF ,0x00,
0xD0 ,0x00,
0xD1 ,0x00,
0xD2 ,0x00,
0xD3 ,0x00,
0xD4 ,0x01,
0xD5 ,0x00,
0xD6 ,0x00,
0xD7 ,0x00,
0xD8 ,0x00,
0xD9 ,0x00,
0xDA ,0x00,
0xDB ,0x00,
0xDC ,0x00,
0xDD ,0xF0,
0xDE ,0x04,
0xDF ,0x97,
0xE0 ,0x50,
0xE1 ,0x50,
0xE2 ,0x14,
0xE3 ,0x1B,
0xE4 ,0x3F,
0xE5 ,0xFF,
0xE6 ,0x00,
0xF0 ,0x00,
0xF1 ,0x00,
0xF2 ,0x00,
0xF3 ,0x00,
0xF6 ,0x00,
0xF7 ,0x00,
0xFD ,0x18,
0xFE ,0x9E,
0xED ,0x01,
0xEF ,0x05, //bank5
0x03 ,0x10,
0x04 ,0xE0,
0x05 ,0x01,
0x06 ,0x04,
0x07 ,0x80,
0x08 ,0x02,
0x09 ,0x09,
0x0A ,0x05,
0x0B ,0x06,
0x0C ,0x04,
0x0D ,0xA1,
0x0E ,0x00,
0x0F ,0x00,
0x10 ,0x02,
0x11 ,0x01,
0x12 ,0x00,
0x13 ,0x00,
0x14 ,0xB8,
0x15 ,0x07,
0x16 ,0x06,
0x17 ,0x03,
0x18 ,0x01,
0x19 ,0x04,
0x1A ,0x06,
0x1B ,0x03,
0x1C ,0x04,
0x1D ,0x08,
0x1E ,0x1A,
0x1F ,0x00,
0x20 ,0x00,
0x21 ,0x1E,
0x22 ,0x1E,
0x23 ,0x01,
0x24 ,0x04,
0x27 ,0x00,
0x28 ,0x00,
0x2A ,0x08,
0x2B ,0x02,
0x2C ,0xA4,
0x2D ,0x06,
0x2E ,0x00,
0x2F ,0x05,
0x30 ,0xE0,
0x31 ,0x01,
0x32 ,0x00,
0x33 ,0x00,
0x34 ,0x00,
0x35 ,0x00,
0x36 ,0x00,
0x37 ,0x00,
0x38 ,0x0E,
0x39 ,0x01,
0x3A ,0x02,
0x3B ,0x00,
0x3C ,0x00,
0x3D ,0x00,
0x3E ,0x00,
0x3F ,0x00,
0x42 ,0x00,
0x40 ,0x16, //24M=16 27M=19
0x41 ,0x12,
0x47 ,0x05,
0x48 ,0x00,
0x49 ,0x01,
0x4D ,0x02,
0x4F ,0x00,
0x54 ,0x0A,
0x55 ,0x01,
0x56 ,0x0A,
0x57 ,0x01,
0x58 ,0x01,
0x59 ,0x01,
0x42 ,0x00,//MIPI PLL , PARALLEL set 0
0x43 ,0x05,//default=04 20170711 JAMES
0x5B ,0x00,
0x5C ,0x00,
0x5D ,0x00,
0x5E ,0x07,
0x5F ,0x08,
0x60 ,0x00,
0x61 ,0x00,
0x62 ,0x00,
0x63 ,0x28,
0x64 ,0x30,
0x65 ,0x9E,
0x66 ,0xB9,
0x67 ,0x52,
0x68 ,0x70,
0x69 ,0x4E,
0x70 ,0x00,
0x71 ,0x00,
0x72 ,0x00,
0x90 ,0x04,
0x91 ,0x01,
0x92 ,0x00,
0x93 ,0x00,
0x94 ,0x04,
0x96 ,0x00,
0x97 ,0x01,
0x98 ,0x01,
0xA0 ,0x00,
0xA1 ,0x01,
0xA2 ,0x00,
0xA3 ,0x01,
0xA4 ,0x00,
0xA5 ,0x01,
0xA6 ,0x00,
0xA7 ,0x00,
0xAA ,0x00,
0xAB ,0x0F,
0xAC ,0x08,
0xAD ,0x09,
0xAE ,0x0A,
0xAF ,0x0B,
0xB0 ,0x00,
0xB1 ,0x00,
0xB2 ,0x01,
0xB3 ,0x00,
0xB4 ,0x00,
0xB5 ,0x0A,
0xB6 ,0x0A,
0xB7 ,0x0A,
0xB8 ,0x0A,
0xB9 ,0x00,
0xBA ,0x00,
0xBB ,0x00,
0xBC ,0x00,
0xBD ,0x00,
0xBE ,0x00,
0xBF ,0x00,
0xC0 ,0x00,
0xC1 ,0x00,
0xC2 ,0x00,
0xC3 ,0x00,
0xC4 ,0x00,
0xC5 ,0x00,
0xC6 ,0x00,
0xC7 ,0x00,
0xC8 ,0x00,
0xD3 ,0x80,
0xD4 ,0x00,
0xD5 ,0x00,
0xD6 ,0x03,
0xD7 ,0x77,
0xD8 ,0x00,
0xED ,0x01,
0xEF ,0x00,
0x11 ,0x00, //數位Cmd_GatedAllClk放開
0xEF ,0x01,
0x02 ,0xFB, //RstN TG
0x05 ,0x01,
0x09 ,0x01,
#endif
};

#if 0
void ____Sensor_Customer_Func____(){ruturn;} // dummy
#endif

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_InitConfig
//  Description :
//------------------------------------------------------------------------------
static void SNR_Cust_InitConfig(void)
{
#if MIPI_TEST_PARAM_EN
extern void UI_GetMIPIParamters(MMP_UBYTE *sot,MMP_UBYTE *delay,MMP_UBYTE *edge) ;
#endif  
  MMP_UBYTE new_sot = 0x1F ,new_delay = 0x08 ,new_edge =  MMPF_VIF_SNR_LATCH_NEG_EDGE ;
	MMP_USHORT 	i;
#if (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)||(SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    MMP_ULONG ulFreq, ulSot;
#endif
	//MMP_ULONG 	ulSensorMCLK = 27000; // 27 M

#if (SENSOR_IF == SENSOR_IF_PARALLEL)
	RTNA_DBG_Str(0, "\r\nPS5250 Parallel\r\n");
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    RTNA_DBG_Str(0, FG_PURPLE("\r\nPS5250 MIPI 2-lane\r\n"));
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
	RTNA_DBG_Str(0, "\r\nPS5250 MIPI 4-lane\r\n");
#endif
#if MIPI_TEST_PARAM_EN
    UI_GetMIPIParamters(&new_sot,&new_delay,&new_edge);
    printc("#New MIPI parameters,SOT:%d,Delay:%d,Latch Edge:%d\r\n",new_sot,new_delay,new_edge);
#endif
	// Init OPR Table
    SensorCustFunc.OprTable->usInitSize                             = (sizeof(SNR_PS5250_Reg_Init_Customer)/sizeof(SNR_PS5250_Reg_Init_Customer[0]))/2;
    SensorCustFunc.OprTable->uspInitTable                           = &SNR_PS5250_Reg_Init_Customer[0];    

    SensorCustFunc.OprTable->bBinTableExist                         = MMP_FALSE;
    SensorCustFunc.OprTable->bInitDoneTableExist                    = MMP_FALSE;

	for (i = 0; i < MAX_SENSOR_RES_MODE; i++)
	{
		SensorCustFunc.OprTable->usSize[i] 							= (sizeof(SNR_PS5250_Reg_Unsupport)/sizeof(SNR_PS5250_Reg_Unsupport[0]))/2;
		SensorCustFunc.OprTable->uspTable[i] 						= &SNR_PS5250_Reg_Unsupport[0];
	}

	// 16:9
    SensorCustFunc.OprTable->usSize[RES_IDX_1920x1080_30P]          = (sizeof(SNR_PS5250_Reg_1920x1080_30P)/sizeof(SNR_PS5250_Reg_1920x1080_30P[0]))/2;
    SensorCustFunc.OprTable->uspTable[RES_IDX_1920x1080_30P]        = &SNR_PS5250_Reg_1920x1080_30P[0];    
    
    #if RES_IDX_1280x720_30P > 0
    SensorCustFunc.OprTable->usSize[RES_IDX_1280x720_30P]          = (sizeof(SNR_PS5250_Reg_1920x1080_30P)/sizeof(SNR_PS5250_Reg_1920x1080_30P[0]))/2;
    SensorCustFunc.OprTable->uspTable[RES_IDX_1280x720_30P]        = &SNR_PS5250_Reg_1920x1080_30P[0];    
    #endif
    
	// Init Vif Setting : Common
    SensorCustFunc.VifSetting->SnrType                              = MMPF_VIF_SNR_TYPE_BAYER;
#if (SENSOR_IF == SENSOR_IF_PARALLEL)
	SensorCustFunc.VifSetting->OutInterface 						= MMPF_VIF_IF_PARALLEL;
#elif (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
	SensorCustFunc.VifSetting->OutInterface 						= MMPF_VIF_IF_MIPI_SINGLE_0;
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
	SensorCustFunc.VifSetting->OutInterface 						= MMPF_VIF_IF_MIPI_DUAL_01;
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
	SensorCustFunc.VifSetting->OutInterface							= MMPF_VIF_IF_MIPI_QUAD;
#endif

	SensorCustFunc.VifSetting->VifPadId 							= MMPF_VIF_MDL_ID0;

	// Init Vif Setting : PowerOn Setting
 	/********************************************/
	// Power On serquence
	// 1. Supply Power
	// 2. Deactive RESET
	// 3. Enable MCLK
	// 4. Active RESET (1ms)
	// 5. Deactive RESET (Wait 150000 clock of MCLK, about 8.333ms under 24MHz)
	/********************************************/

	SensorCustFunc.VifSetting->powerOnSetting.bTurnOnExtPower 		= MMP_TRUE;
	SensorCustFunc.VifSetting->powerOnSetting.usExtPowerPin 		= MMP_GPIO_MAX;
	SensorCustFunc.VifSetting->powerOnSetting.bFirstEnPinHigh 		= MMP_TRUE;
	SensorCustFunc.VifSetting->powerOnSetting.ubFirstEnPinDelay 	= 0;//10;
	SensorCustFunc.VifSetting->powerOnSetting.bNextEnPinHigh 		= MMP_FALSE;
	SensorCustFunc.VifSetting->powerOnSetting.ubNextEnPinDelay 		= 0;//100;
	SensorCustFunc.VifSetting->powerOnSetting.bTurnOnClockBeforeRst = MMP_TRUE;
	SensorCustFunc.VifSetting->powerOnSetting.bFirstRstPinHigh 		= MMP_FALSE;
	SensorCustFunc.VifSetting->powerOnSetting.ubFirstRstPinDelay 	= 2;//100;
	SensorCustFunc.VifSetting->powerOnSetting.bNextRstPinHigh 		= MMP_TRUE;
	SensorCustFunc.VifSetting->powerOnSetting.ubNextRstPinDelay 	= 1;//100;

	// Init Vif Setting : PowerOff Setting
	SensorCustFunc.VifSetting->powerOffSetting.bEnterStandByMode 	= MMP_FALSE;
	SensorCustFunc.VifSetting->powerOffSetting.usStandByModeReg 	= 0x00;
	SensorCustFunc.VifSetting->powerOffSetting.usStandByModeMask 	= 0x00;
	SensorCustFunc.VifSetting->powerOffSetting.bEnPinHigh 			= MMP_TRUE;
	SensorCustFunc.VifSetting->powerOffSetting.ubEnPinDelay 		= 5;//20;
	SensorCustFunc.VifSetting->powerOffSetting.bTurnOffMClock 		= MMP_TRUE;
	SensorCustFunc.VifSetting->powerOffSetting.bTurnOffExtPower 	= MMP_TRUE;
	SensorCustFunc.VifSetting->powerOffSetting.usExtPowerPin 		= MMP_GPIO_MAX; // it might be defined in Config_SDK.h

	SensorCustFunc.VifSetting->clockAttr.bClkOutEn 					= MMP_TRUE;
	SensorCustFunc.VifSetting->clockAttr.ubClkFreqDiv 				= 0;
	SensorCustFunc.VifSetting->clockAttr.ulMClkFreq 				= 24000;
	SensorCustFunc.VifSetting->clockAttr.ulDesiredFreq 				= 24000;
	SensorCustFunc.VifSetting->clockAttr.ubClkPhase 				= MMPF_VIF_SNR_PHASE_DELAY_NONE;
	SensorCustFunc.VifSetting->clockAttr.ubClkPolarity 				= MMPF_VIF_SNR_CLK_POLARITY_POS;
	SensorCustFunc.VifSetting->clockAttr.ubClkSrc 					= MMPF_VIF_SNR_CLK_SRC_PMCLK;

	// Init Vif Setting : Parallel Sensor Setting
	SensorCustFunc.VifSetting->paralAttr.ubLatchTiming 				= MMPF_VIF_SNR_LATCH_POS_EDGE;
	SensorCustFunc.VifSetting->paralAttr.ubHsyncPolarity 			= MMPF_VIF_SNR_CLK_POLARITY_POS;
	SensorCustFunc.VifSetting->paralAttr.ubVsyncPolarity 			= MMPF_VIF_SNR_CLK_POLARITY_POS;
    SensorCustFunc.VifSetting->paralAttr.ubBusBitMode               = MMPF_VIF_SNR_PARAL_BITMODE_10;
    
	// Init Vif Setting : MIPI Sensor Setting
	SensorCustFunc.VifSetting->mipiAttr.bClkDelayEn 				= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bClkLaneSwapEn 				= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.usClkDelay 					= 0;
	SensorCustFunc.VifSetting->mipiAttr.ubBClkLatchTiming 			= new_edge ;// MMPF_VIF_SNR_LATCH_NEG_EDGE;
	
#if (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)||(SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
    MMPF_PLL_GetGroupFreq(CLK_GRP_SNR, &ulFreq);
    ulSot =  0x1F;//0x14;//F;//(0x1F * ulFreq) / 400000; // SOT 0x1F is for VIF 400MHz
#endif
	
#if (SENSOR_IF == SENSOR_IF_MIPI_1_LANE)
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneEn[0] 				= MMP_TRUE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneEn[1] 				= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneEn[2] 				= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneEn[3] 				= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataDelayEn[0] 			= MMP_TRUE;
	SensorCustFunc.VifSetting->mipiAttr.bDataDelayEn[1] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataDelayEn[2] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataDelayEn[3] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneSwapEn[0] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneSwapEn[1] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneSwapEn[2] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneSwapEn[3] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.ubDataLaneSrc[0] 			= MMPF_VIF_MIPI_DATA_SRC_PHY_0;
	SensorCustFunc.VifSetting->mipiAttr.ubDataLaneSrc[1] 			= MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF;
	SensorCustFunc.VifSetting->mipiAttr.ubDataLaneSrc[2] 			= MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF;
	SensorCustFunc.VifSetting->mipiAttr.ubDataLaneSrc[3] 			= MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF;
	SensorCustFunc.VifSetting->mipiAttr.usDataDelay[0] 				= new_delay ;
	SensorCustFunc.VifSetting->mipiAttr.usDataDelay[1] 				= new_delay;
	SensorCustFunc.VifSetting->mipiAttr.usDataDelay[2] 				= new_delay;
	SensorCustFunc.VifSetting->mipiAttr.usDataDelay[3] 				= new_delay;
	SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[0] 			= new_sot  ;
	SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[1] 			= new_sot  ;
	SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[2] 			= new_sot  ;
	SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[3] 			= new_sot  ;
#elif (SENSOR_IF == SENSOR_IF_MIPI_2_LANE)
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneEn[0] 				= MMP_TRUE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneEn[1] 				= MMP_TRUE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneEn[2] 				= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneEn[3] 				= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataDelayEn[0] 			= MMP_TRUE;
	SensorCustFunc.VifSetting->mipiAttr.bDataDelayEn[1] 			= MMP_TRUE;
	SensorCustFunc.VifSetting->mipiAttr.bDataDelayEn[2] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataDelayEn[3] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneSwapEn[0] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneSwapEn[1] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneSwapEn[2] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneSwapEn[3] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.ubDataLaneSrc[0] 			= MMPF_VIF_MIPI_DATA_SRC_PHY_0;
	SensorCustFunc.VifSetting->mipiAttr.ubDataLaneSrc[1] 			= MMPF_VIF_MIPI_DATA_SRC_PHY_1;
	SensorCustFunc.VifSetting->mipiAttr.ubDataLaneSrc[2] 			= MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF;
	SensorCustFunc.VifSetting->mipiAttr.ubDataLaneSrc[3] 			= MMPF_VIF_MIPI_DATA_SRC_PHY_UNDEF;
	SensorCustFunc.VifSetting->mipiAttr.usDataDelay[0] 				= new_delay; //0x08;
	SensorCustFunc.VifSetting->mipiAttr.usDataDelay[1] 				= new_delay; //0x08;
	SensorCustFunc.VifSetting->mipiAttr.usDataDelay[2] 				= new_delay; //0x08;
	SensorCustFunc.VifSetting->mipiAttr.usDataDelay[3] 				= new_delay; //0x08;
	SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[0] 			= new_sot;
	SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[1] 			= new_sot;
	SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[2] 			= new_sot;
	SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[3] 			= new_sot;
#elif (SENSOR_IF == SENSOR_IF_MIPI_4_LANE)
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneEn[0] 				= MMP_TRUE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneEn[1] 				= MMP_TRUE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneEn[2] 				= MMP_TRUE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneEn[3] 				= MMP_TRUE;
	SensorCustFunc.VifSetting->mipiAttr.bDataDelayEn[0] 			= MMP_TRUE;
	SensorCustFunc.VifSetting->mipiAttr.bDataDelayEn[1] 			= MMP_TRUE;
	SensorCustFunc.VifSetting->mipiAttr.bDataDelayEn[2] 			= MMP_TRUE;
	SensorCustFunc.VifSetting->mipiAttr.bDataDelayEn[3] 			= MMP_TRUE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneSwapEn[0] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneSwapEn[1] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneSwapEn[2] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.bDataLaneSwapEn[3] 			= MMP_FALSE;
	SensorCustFunc.VifSetting->mipiAttr.ubDataLaneSrc[0] 			= MMPF_VIF_MIPI_DATA_SRC_PHY_0;
	SensorCustFunc.VifSetting->mipiAttr.ubDataLaneSrc[1] 			= MMPF_VIF_MIPI_DATA_SRC_PHY_1;
	SensorCustFunc.VifSetting->mipiAttr.ubDataLaneSrc[2] 			= MMPF_VIF_MIPI_DATA_SRC_PHY_2;
	SensorCustFunc.VifSetting->mipiAttr.ubDataLaneSrc[3] 			= MMPF_VIF_MIPI_DATA_SRC_PHY_3;
	SensorCustFunc.VifSetting->mipiAttr.usDataDelay[0] 				= new_delay;
	SensorCustFunc.VifSetting->mipiAttr.usDataDelay[1] 				= new_delay;
	SensorCustFunc.VifSetting->mipiAttr.usDataDelay[2] 				= new_delay;
	SensorCustFunc.VifSetting->mipiAttr.usDataDelay[3] 				= new_delay;
	SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[0] 			= new_sot;
	SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[1] 			= new_sot;
	SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[2] 			= new_sot;
	SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[3] 			= new_sot;
#endif

	// Init Vif Setting : Color ID Setting
	SensorCustFunc.VifSetting->colorId.VifColorId 					= MMPF_VIF_COLORID_11;
	SensorCustFunc.VifSetting->colorId.CustomColorId.bUseCustomId 	= MMP_TRUE;
	SensorCustFunc.VifSetting->colorId.CustomColorId.Rot0d_Id[0]   = MMPF_VIF_COLORID_11;
	SensorCustFunc.VifSetting->colorId.CustomColorId.Rot0d_Id[1]   = MMPF_VIF_COLORID_11;	
	SensorCustFunc.VifSetting->colorId.CustomColorId.V_Flip_Id[0]   = MMPF_VIF_COLORID_11;
	SensorCustFunc.VifSetting->colorId.CustomColorId.V_Flip_Id[1]   = MMPF_VIF_COLORID_11;
	SensorCustFunc.VifSetting->colorId.CustomColorId.H_Flip_Id[0]   = MMPF_VIF_COLORID_10;
	SensorCustFunc.VifSetting->colorId.CustomColorId.H_Flip_Id[1]   = MMPF_VIF_COLORID_10;
	SensorCustFunc.VifSetting->colorId.CustomColorId.HV_Flip_Id[0]   = MMPF_VIF_COLORID_10;
	SensorCustFunc.VifSetting->colorId.CustomColorId.HV_Flip_Id[1]   = MMPF_VIF_COLORID_10;

	/*
	printc("SOT [%d,%d,%d,%d],SNR.CLK:%d\r\n", SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[0],
                                    SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[1],
                                	SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[2],
                                	SensorCustFunc.VifSetting->mipiAttr.ubDataSotCnt[3],
                                	ulFreq ); 
    */                                	
}

//20150526
//lv1-7, 2	3	6	11	17	30	60
#if 1//	new extent node for18//LV1,		LV2,		LV3,		LV4,		LV5,		LV6,		LV7,		LV8,		LV9,		LV10,	LV11,	LV12,	LV13,	LV14,	LV15,	LV16 	LV17  	LV18
//abby curve iq 12
ISP_UINT32 AE_Bias_tbl[54] =
/*lux*/						{2,			3,			5,			9,			16, 		31, 		63, 		122, 		252,		458,	836,	1684,	3566,	6764,	13279,	27129,	54640, 108810/*930000=LV17*/
/*ENG*/						,0x2FFFFFF, 4841472*2,	3058720,	1962240,	1095560,  	616000, 	334880, 	181720,     96600,	 	52685,	27499,	14560,	8060,	4176,	2216,	1144,	600,   300
/*Tar*/						,50,		50,		 	58,	        70,			86,	 		94,	 		140,	 	180,	    220,	    230,	250,	255,	260,	265,	275,	282,	283,   284
 };	
#define AE_tbl_size  (18)	//32  35  44  50
#endif

#define AGAIN_1X  0x100
#define DGAIN_1X  0x100
#define PS5250_MaxGain 28

ISP_UINT32 ISP_dgain, s_gain;
//ISP_UINT32 isp_gain;
ISP_UINT32 sensor_gain_set = 4096;

#define SENSOR_HIGH_TEMPERATURE_CONTROL 0
#if SENSOR_HIGH_TEMPERATURE_CONTROL
	MMP_USHORT sensor_rgE1 = 0xFF, sensor_rgE2 = 0xFF;
	MMP_USHORT sensor_rg1B = 0x0F, sensor_rg1C = 0xFF;
#endif


//------------------------------------------------------------------------------
//  Function    : SNR_Cust_DoAE_FrmSt
//  Description :
//------------------------------------------------------------------------------
void SNR_Cust_DoAE_FrmSt(MMP_UBYTE ubSnrSel, MMP_ULONG ulFrameCnt)
{
#if 1
	static ISP_UINT16 ae_gain;
	static ISP_UINT16 ae_shutter;
	static ISP_UINT16 ae_vsync;
					
	MMP_ULONG ulVsync = 0;
	MMP_ULONG ulShutter = 0;

	if(*(MMP_UBYTE *) 0x800070c8 == 0) 
		return ;
	
	if (ulFrameCnt <  1/*m_AeTime.ubPeriod*/) {
		return ;
	}


	if ((ulFrameCnt % m_AeTime.ubPeriod) == 1) 
	{
		ISP_IF_AE_Execute();
    
		ae_shutter 	= ISP_IF_AE_GetShutter();
		ae_vsync 	= ISP_IF_AE_GetVsync();
		ulVsync 	= (gSnrLineCntPerSec[ubSnrSel] * ISP_IF_AE_GetVsync()) / ISP_IF_AE_GetVsyncBase();
		ulShutter 	= (gSnrLineCntPerSec[ubSnrSel] * ISP_IF_AE_GetShutter()) / ISP_IF_AE_GetShutterBase();
		
		s_gain = ISP_IF_AE_GetGain(); 
		if( s_gain > ISP_IF_AE_GetGainBase() * PS5250_MaxGain )
		{
			ISP_dgain  = DGAIN_1X * s_gain /( ISP_IF_AE_GetGainBase()  * PS5250_MaxGain );		
			s_gain = ISP_IF_AE_GetGainBase()  * PS5250_MaxGain;
		}
	    else
		{
		    ISP_dgain = DGAIN_1X;
		}
	 	//gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0xEF, 0x01);//set to bank1
		gsSensorFunction->MMPF_Sensor_SetShutter(ubSnrSel, ulShutter, ulVsync);
		gsSensorFunction->MMPF_Sensor_SetGain(ubSnrSel, s_gain);
		gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x09, 0x01); //shutter & gain update, if update in frame active next 2 frames, if blanking next frame.
		//dbg_printf(0,"%x %x %x\r\n", ISP_IF_AWB_GetGainR(), ISP_IF_AWB_GetGainG(), ISP_IF_AWB_GetGainB());
		//printc("%x\r\n", ISP_IF_AE_GetGain());
	}
	
	
	if ((ulFrameCnt % m_AeTime.ubPeriod) == 1)
	{
		ISP_IF_IQ_SetAEGain(ISP_dgain, DGAIN_1X);
	}
	
	
	#if SENSOR_HIGH_TEMPERATURE_CONTROL // update  sensor_rgE1 / sensor_rgE2
		if ((ulFrameCnt % m_AeTime.ubPeriod) != m_AeTime.ubFrmStSetShutFrmCnt)
		{
			{
			 	gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0xEF, 0x01);//bank Group1		
				gsSensorFunction->MMPF_Sensor_GetReg(ubSnrSel, 0xE1, &sensor_rgE1);//read 0xE1
				gsSensorFunction->MMPF_Sensor_GetReg(ubSnrSel, 0xE2, &sensor_rgE2);//read 0xE2
			}
			
			{
				ISP_UINT16 DigDac1 = 0;
			 	gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0xEF, 0x02);//bank Group2
				gsSensorFunction->MMPF_Sensor_GetReg(ubSnrSel, 0x1B, &sensor_rg1B);//read 0x1B
				gsSensorFunction->MMPF_Sensor_GetReg(ubSnrSel, 0x1C, &sensor_rg1C);//read 0x1C
			
				DigDac1 = ((sensor_rg1B &0x07) <<8) + (sensor_rg1C & 0xFF);
			
				if(DigDac1 > 0x20  || sensor_gain_set < 0x200) 
				{
				 	gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0xEF, 0x01);//bank GroupB		
					gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0xE1, sensor_rgE1 |0x10);//read 0xE1
					gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0xE2, sensor_rgE2 |0x08);//read 0xE2		
				}	
				else if(DigDac1 < 0x1C  && sensor_gain_set > 0x2AB)
				{
				 	gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0xEF, 0x01);//bank GroupB		
					gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0xE1, sensor_rgE1 &0xEF);//read 0xE1
					gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0xE2, sensor_rgE2 &0xF7);//read 0xE2		
				}
				gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x09, 0x01); //shutter & gain update, if update in frame active next 2 frames, if blanking next frame.			
			}
		}
	#endif	
		
#endif

}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_DoAE_FrmEnd
//  Description :
//------------------------------------------------------------------------------
void SNR_Cust_DoAE_FrmEnd(MMP_UBYTE ubSnrSel, MMP_ULONG ulFrameCnt)
{
	// TBD
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_DoAWB
//  Description :
//------------------------------------------------------------------------------
void SNR_Cust_DoAWB(MMP_UBYTE ubSnrSel, MMP_ULONG ulFrameCnt)
{
	// TBD
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_DoIQ
//  Description :
//------------------------------------------------------------------------------
void SNR_Cust_DoIQ(MMP_UBYTE ubSnrSel, MMP_ULONG ulFrameCnt)
{
	// TBD
}

static MMP_UBYTE SNR_GetGainIndex( MMP_USHORT val)
{
  MMP_UBYTE i ;
  for(i=0;i<SZ_GAIN_TBL;i++) {
    if(val >= PS5250_GainTable[i] ) {
      return i ;
    }
  }
  printc("[PS5250] : Bad Gain Idx\r\n"); 
  return 0 ;
}
//------------------------------------------------------------------------------
//  Function    : SNR_Cust_SetGain
//  Description :
//------------------------------------------------------------------------------
void SNR_Cust_SetGain(MMP_UBYTE ubSnrSel, MMP_ULONG ulGain)
{
#if 1

	ISP_UINT32 i;
	ISP_UINT32 set_gain = 0x100, sensor_gain;
	ISP_UINT32 target_gain;
  ISP_UINT8  gain_idx ;
  	
	target_gain = ISP_MAX(ulGain,ISP_IF_AE_GetGainBase()) ;

	sensor_gain = 0x10 * target_gain / ISP_IF_AE_GetGainBase();
	
	if(sensor_gain < 0x20){
		i = sensor_gain - 0x10;  //index 0~15
	}	
	else if(sensor_gain < 0x40){
		i = sensor_gain / 2; //index 16~31
	}	
	else if(sensor_gain < 0x80){
		i = sensor_gain / 4 + 0x10; //index 32~47
	}
	else if(sensor_gain < 0x100){
		i = sensor_gain / 8 + 0x20; //index 48~63
	}
	else if(sensor_gain < 0x200){
		i = sensor_gain / 16 + 0x30; //index 64~79
	}
	else
		i = 80;
		
	sensor_gain_set =  PS5250_GainTable[i];
  set_gain = ISP_IF_AE_GetGainBase() * 4096 / sensor_gain_set;
  ISP_dgain = target_gain * ISP_dgain / set_gain;  	
  	// Don't let sensor gain under 1.25x ( PS5250 is 1.25x)
	if (sensor_gain_set > 3277)
	    sensor_gain_set = 3277; 
  
  gain_idx = SNR_GetGainIndex( sensor_gain_set ); 	    
	gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0xEF, 0x01);//bank GroupB
	gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x83, gain_idx);//bank GroupB
	
	
#endif
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_SetShutter
//  Description :
//------------------------------------------------------------------------------
void SNR_Cust_SetShutter(MMP_UBYTE ubSnrSel, MMP_ULONG shutter, MMP_ULONG vsync)
{ // shutter(2~ LPF-2) = LPF(vsync 0x0A~0x0B) - Ny(0x0C~0x0D)
#if 1
	ISP_UINT32 new_vsync 	= vsync;
	ISP_UINT32 new_shutter 	= shutter;
	
	if( shutter == 0 || vsync == 0)
	{
		new_vsync 	= (gSnrLineCntPerSec[ubSnrSel] * ISP_IF_AE_GetVsync()) / ISP_IF_AE_GetVsyncBase();
		new_shutter = (gSnrLineCntPerSec[ubSnrSel] * ISP_IF_AE_GetShutter()) / ISP_IF_AE_GetShutterBase();
	}

	new_vsync 	= ISP_MIN(ISP_MAX((new_shutter), new_vsync), 0xFFFF);
	new_shutter = ISP_MIN(ISP_MAX(new_shutter, 3), (new_vsync - 2));
	
	// vsync fix FPS, so vsync not changed.
	gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0xEF, 0x01);//bank GroupB
	gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x0A, (new_vsync >> 8));
	gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x0B, new_vsync);

	// shutter = Vsync - Ny
	gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x0C, (((new_vsync - new_shutter) >> 8) & 0xFF));
	gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x0D, (( new_vsync - new_shutter) & 0xFF));
#endif
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_SetExposure
//  Description :
//------------------------------------------------------------------------------
// defined but not used
/* static void SNR_Cust_SetExposure(MMP_UBYTE ubSnrSel, MMP_ULONG ulGain, MMP_ULONG shutter, MMP_ULONG vsync) */
/* { */
/* #if (ISP_EN) */
    /* // TBD */
/* #endif */
/* } */

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_SetFlip
//  Description :
//------------------------------------------------------------------------------
void SNR_Cust_SetFlip(MMP_UBYTE ubSnrSel, MMP_UBYTE ubMode)
{
#if 0//TBD
    MMP_USHORT vflip,hflip ;
    // protected by upper layer api
    //ISP_IF_3A_Control(ISP_3A_PAUSE);

    gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0xEF, 0x01);//bank GroupB
    gsSensorFunction->MMPF_Sensor_GetReg(ubSnrSel, 0x1B, &hflip); // 
    gsSensorFunction->MMPF_Sensor_GetReg(ubSnrSel, 0x1D, &vflip); // 

    switch(ubMode) {
    case MMPF_SENSOR_COLUMN_FLIP:
        vflip = vflip | 0x80 ;
        hflip = hflip & 0x7F ;
        break;
    case MMPF_SENSOR_ROW_FLIP:
        vflip = vflip & 0x7F ;
        hflip = hflip | 0x80 ;
        break;
    case MMPF_SENSOR_COLROW_FLIP:
        vflip = vflip | 0x80 ;
        hflip = hflip | 0x80 ;
        break;
    case MMPF_SENSOR_NO_FLIP:
    default:
        hflip = hflip & 0x7F ;
        vflip = vflip & 0x7F ;            
    	break;
    }

    gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x1B, hflip); // 
    gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x1D, vflip); // 
    // Let it sync by shutter 
    //gsSensorFunction->MMPF_Sensor_SetReg(ubSnrSel, 0x09, 0x01); // active
    //ISP_IF_3A_Control(ISP_3A_RECOVER);
#endif    
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_SetRotate
//  Description :
//------------------------------------------------------------------------------
void SNR_Cust_SetRotate(MMP_UBYTE ubSnrSel, MMP_UBYTE ubMode)
{
	// TBD
}

//------------------------------------------------------------------------------
//  Function    : SNR_Cust_CheckVersion
//  Description :
//------------------------------------------------------------------------------
void SNR_Cust_CheckVersion(MMP_UBYTE ubSnrSel, MMP_ULONG *pulVersion)
{
	// TBD
}



void SNR_Cust_Switch3ASpeed(MMP_BOOL slow)
{
  MMPF_SENSOR_CUSTOMER *cust = (MMPF_SENSOR_CUSTOMER *)&SensorCustFunc ;
  printc("[TBD] : Switch to slow 3A\r\n");
  if(slow) {
    
  }
  else {
    
  }
}

void SNR_Cust_SetNightVision(MMP_BOOL night)
{
  MMPF_SENSOR_CUSTOMER *cust = (MMPF_SENSOR_CUSTOMER *)&SensorCustFunc ;
  //printc("[TBD] : NV_mode:%d\r\n", night);
  if(night) {
    ISP_IF_IQ_SetSysMode(0);
    //if(ISP_IF_F_GetWDREn() != 0) ISP_IF_F_SetWDREn(0);
    ISP_IF_F_SetImageEffect(ISP_IMAGE_EFFECT_GREY);  // Grey
  }
  else {
    ISP_IF_IQ_SetSysMode(1);
    //if(ISP_IF_F_GetWDREn() != 1) ISP_IF_F_SetWDREn(1);
    ISP_IF_F_SetImageEffect(ISP_IMAGE_EFFECT_NORMAL);  // Grey    
  }
}

MMPF_SENSOR_CUSTOMER SensorCustFunc = 
{
    SNR_Cust_InitConfig,
    SNR_Cust_DoAE_FrmSt,
    SNR_Cust_DoAE_FrmEnd,
    SNR_Cust_DoAWB,
    SNR_Cust_DoIQ,
    SNR_Cust_SetGain,
    SNR_Cust_SetShutter,
    SNR_Cust_SetFlip,
    SNR_Cust_SetRotate,
    SNR_Cust_CheckVersion,
    SNR_Cust_Switch3ASpeed,
    SNR_Cust_SetNightVision,
	&m_SensorRes,
	&m_OprTable,
	&m_VifSetting,
	&m_I2cmAttr,
	&m_AwbTime,
	&m_AeTime,
	&m_AfTime,
	MMP_SNR_PRIO_PRM
};

int SNR_Module_Init(void)
{
    if (SensorCustFunc.sPriority == MMP_SNR_PRIO_PRM)
        MMPF_SensorDrv_Register(PRM_SENSOR, &SensorCustFunc);
    else
        MMPF_SensorDrv_Register(SCD_SENSOR, &SensorCustFunc); 
    
    return 0;
}

/* #pragma arm section code = "initcall", rodata = "initcall", rwdata = "initcall", zidata = "initcall" */
/* #pragma O0 */
ait_module_init(SNR_Module_Init);
/* #pragma */
/* #pragma arm section rodata, rwdata, zidata */

#endif  //BIND_SENSOR_PS5250
#endif	//SENSOR_EN
